<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball Physics Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
        }
        
        #canvas {
            border: 2px solid white;
            background-color: rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border-radius: 4px;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .control-item {
            margin: 8px 0;
            font-size: 14px;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 8px;
        }
        
        button:hover {
            background: #764ba2;
        }
        
        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <div class="control-item">
            <button onclick="addBalls(10)">Add 10 Balls</button>
        </div>
        <div class="control-item">
            <button onclick="resetSimulation()">Reset</button>
        </div>
        <div class="control-item">
            <label>
                <input type="checkbox" id="damping-toggle" checked onchange="toggleDamping()">
                Enable Damping
            </label>
        </div>
    </div>
    
    <div class="stats">
        <div>Balls: <span id="ball-count">0</span></div>
        <div>FPS: <span id="fps">0</span></div>
        <div>Collisions: <span id="collision-count">0</span></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = Math.min(window.innerWidth - 40, 1000);
        canvas.height = Math.min(window.innerHeight - 40, 800);
        
        // Physics configuration
        const config = {
            gravity: 0.3,
            damping: 0.98,
            velocityDamping: 0.99,
            minVelocity: 0.01,
            collisionDamping: 0.85,
            separationCoefficient: 0.5,
            maxBalls: 500
        };
        
        let balls = [];
        let frameCount = 0;
        let lastTime = Date.now();
        let fps = 0;
        let totalCollisions = 0;
        let enableDamping = true;
        
        class Ball {
            constructor(x, y, radius = 5, velocityX = 0, velocityY = 0) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.vx = velocityX;
                this.vy = velocityY;
                this.mass = Math.PI * radius * radius;
                this.color = this.randomColor();
                this.lastCollisionTime = 0;
            }
            
            randomColor() {
                const colors = [
                    '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
                    '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B88B', '#A9DFBF'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            update() {
                // Apply gravity
                this.vy += config.gravity;
                
                // Apply air resistance/damping
                if (enableDamping) {
                    this.vx *= config.velocityDamping;
                    this.vy *= config.velocityDamping;
                }
                
                // Stop very slow moving balls to prevent jitter
                if (Math.abs(this.vx) < config.minVelocity) this.vx = 0;
                if (Math.abs(this.vy) < config.minVelocity) this.vy = 0;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Boundary collision - walls
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx = Math.abs(this.vx) * config.collisionDamping;
                }
                if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius;
                    this.vx = -Math.abs(this.vx) * config.collisionDamping;
                }
                
                // Boundary collision - floor
                if (this.y + this.radius > canvas.height) {
                    this.y = canvas.height - this.radius;
                    this.vy = -Math.abs(this.vy) * config.collisionDamping;
                }
                
                // Boundary collision - ceiling
                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy = Math.abs(this.vy) * config.collisionDamping;
                }
            }
            
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
        
        function addBalls(count) {
            const newCount = Math.min(balls.length + count, config.maxBalls);
            const toAdd = newCount - balls.length;
            
            for (let i = 0; i < toAdd; i++) {
                const radius = 3 + Math.random() * 4;
                const x = Math.random() * (canvas.width - radius * 2) + radius;
                const y = Math.random() * (canvas.height * 0.5) + radius;
                const vx = (Math.random() - 0.5) * 4;
                const vy = (Math.random() - 0.5) * 4;
                
                balls.push(new Ball(x, y, radius, vx, vy));
            }
        }
        
        function resetSimulation() {
            balls = [];
            totalCollisions = 0;
            addBalls(20);
        }
        
        function toggleDamping() {
            enableDamping = document.getElementById('damping-toggle').checked;
        }
        
        function checkCollisions() {
            let collisionCount = 0;
            const threshold = 0.016; // ~1 frame at 60fps
            
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const ball1 = balls[i];
                    const ball2 = balls[j];
                    
                    // Calculate distance
                    const dx = ball2.x - ball1.x;
                    const dy = ball2.y - ball1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = ball1.radius + ball2.radius;
                    
                    if (distance < minDistance) {
                        const now = Date.now() / 1000;
                        
                        // Prevent multiple collision detections in quick succession
                        if (now - ball1.lastCollisionTime > threshold && 
                            now - ball2.lastCollisionTime > threshold) {
                            
                            collisionCount++;
                            ball1.lastCollisionTime = now;
                            ball2.lastCollisionTime = now;
                            
                            // Separate overlapping balls
                            const overlap = minDistance - distance;
                            const separationX = (dx / distance) * overlap * config.separationCoefficient;
                            const separationY = (dy / distance) * overlap * config.separationCoefficient;
                            
                            ball1.x -= separationX;
                            ball1.y -= separationY;
                            ball2.x += separationX;
                            ball2.y += separationY;
                            
                            // Elastic collision response
                            const angle = Math.atan2(dy, dx);
                            const sin = Math.sin(angle);
                            const cos = Math.cos(angle);
                            
                            // Rotate velocities
                            const vx1 = ball1.vx * cos + ball1.vy * sin;
                            const vy1 = ball1.vy * cos - ball1.vx * sin;
                            const vx2 = ball2.vx * cos + ball2.vy * sin;
                            const vy2 = ball2.vy * cos - ball2.vx * sin;
                            
                            // Conservation of momentum for x-axis (using mass)
                            const m1 = ball1.mass;
                            const m2 = ball2.mass;
                            const totalMass = m1 + m2;
                            
                            const vx1Final = ((m1 - m2) * vx1 + 2 * m2 * vx2) / totalMass;
                            const vx2Final = ((m2 - m1) * vx2 + 2 * m1 * vx1) / totalMass;
                            
                            // No exchange on y-axis (only for 1D simplified)
                            const vy1Final = vy1;
                            const vy2Final = vy2;
                            
                            // Rotate back
                            ball1.vx = vx1Final * cos - vy1Final * sin;
                            ball1.vy = vy1Final * cos + vx1Final * sin;
                            ball2.vx = vx2Final * cos - vy2Final * sin;
                            ball2.vy = vy2Final * cos + vx2Final * sin;
                            
                            // Apply additional damping to reduce excessive bouncing
                            ball1.vx *= 0.95;
                            ball1.vy *= 0.95;
                            ball2.vx *= 0.95;
                            ball2.vy *= 0.95;
                        }
                    }
                }
            }
            
            return collisionCount;
        }
        
        function animate() {
            // Clear canvas
            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw balls
            for (let ball of balls) {
                ball.update();
                ball.draw();
            }
            
            // Check and handle collisions
            const collisions = checkCollisions();
            totalCollisions += collisions;
            
            // Update stats
            frameCount++;
            const now = Date.now();
            if (now - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = now;
            }
            
            document.getElementById('ball-count').textContent = balls.length;
            document.getElementById('fps').textContent = fps;
            document.getElementById('collision-count').textContent = totalCollisions;
            
            requestAnimationFrame(animate);
        }
        
        // Initialize
        addBalls(20);
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = Math.min(window.innerWidth - 40, 1000);
            canvas.height = Math.min(window.innerHeight - 40, 800);
        });
    </script>
</body>
</html>