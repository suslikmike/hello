<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Balls</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        .ball {
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 30% 30%, #ffffff, #ff6b6b);
            border-radius: 50%;
            position: absolute;
            transform-origin: 50% 100%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3),
                        inset -10px -10px 20px rgba(0, 0, 0, 0.2),
                        inset 5px 5px 10px rgba(255, 255, 255, 0.3);
            cursor: grab;
            user-select: none;
            transition: none;
            pointer-events: auto;
        }

        .ball:active {
            cursor: grabbing;
        }

        .ball::before {
            content: '';
            position: absolute;
            top: 20px;
            left: 25px;
            width: 15px;
            height: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .shadow {
            position: absolute;
            width: 60px;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            transform-origin: center;
            pointer-events: none;
        }

        h1 {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            font-size: 2.5em;
            letter-spacing: 2px;
            pointer-events: none;
            z-index: 10;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 100;
            min-width: 200px;
        }

        .control-panel label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
            font-size: 14px;
        }

        .control-panel input {
            width: 100%;
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 5px;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .control-panel button {
            width: 100%;
            padding: 10px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
        }

        .control-panel button:hover {
            background: #5568d3;
        }

        .control-panel button:active {
            background: #4457c2;
        }
    </style>
</head>
<body>
    <h1>Bouncing Balls</h1>
    <div class="control-panel">
        <label for="ballCount">Number of Balls:</label>
        <input type="number" id="ballCount" min="1" max="50" value="1">
        <button id="spawnBtn">Spawn Balls</button>
    </div>
    <div class="container" id="container"></div>

    <script>
        const container = document.getElementById('container');
        const ballCountInput = document.getElementById('ballCount');
        const spawnBtn = document.getElementById('spawnBtn');

        // Physics constants
        const GRAVITY = 0.8;
        const BOUNCE_DAMPING = 0.7;
        const FRICTION = 0.98;
        const BALL_RADIUS = 40;
        const BALL_DIAMETER = BALL_RADIUS * 2;
        let FLOOR_Y = window.innerHeight - BALL_RADIUS;
        const VELOCITY_SMOOTHING = 0.3;
        const COLLISION_DAMPING = 0.9; // Energy loss in ball-to-ball collisions

        // Array to store all balls
        let balls = [];
        let draggedBall = null;

        // Ball class
        class Ball {
            constructor(id, startX, startY) {
                this.id = id;
                this.x = startX;
                this.y = startY;
                this.vx = 0;
                this.vy = 0;
                this.isDragging = false;
                this.dragOffsetX = 0;
                this.dragOffsetY = 0;
                this.lastSquash = 0;
                this.lastDragX = 0;
                this.lastDragY = 0;
                this.lastDragTime = 0;

                // Create DOM elements
                this.shadow = document.createElement('div');
                this.shadow.className = 'shadow';
                this.element = document.createElement('div');
                this.element.className = 'ball';
                this.element.dataset.ballId = id;

                container.appendChild(this.shadow);
                container.appendChild(this.element);

                // Add event listeners
                this.element.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.element.addEventListener('touchstart', (e) => this.handleTouchStart(e));
            }

            handleMouseDown(e) {
                if (draggedBall) return; // Prevent multiple drags
                draggedBall = this;
                this.isDragging = true;
                const rect = this.element.getBoundingClientRect();
                this.dragOffsetX = e.clientX - (rect.left + BALL_RADIUS);
                this.dragOffsetY = e.clientY - (rect.top + BALL_RADIUS);
                
                this.lastDragX = e.clientX - this.dragOffsetX;
                this.lastDragY = e.clientY - this.dragOffsetY;
                this.lastDragTime = Date.now();
                e.preventDefault();
            }

            handleTouchStart(e) {
                if (draggedBall) return;
                draggedBall = this;
                this.isDragging = true;
                const touch = e.touches[0];
                const rect = this.element.getBoundingClientRect();
                this.dragOffsetX = touch.clientX - (rect.left + BALL_RADIUS);
                this.dragOffsetY = touch.clientY - (rect.top + BALL_RADIUS);
                
                this.lastDragX = touch.clientX - this.dragOffsetX;
                this.lastDragY = touch.clientY - this.dragOffsetY;
                this.lastDragTime = Date.now();
                e.preventDefault();
            }

            updatePosition() {
                const ballX = this.x - BALL_RADIUS;
                const ballY = this.y - BALL_RADIUS;
                
                // Calculate squash effect
                const distanceFromGround = FLOOR_Y - this.y;
                let squashY = 1;
                let squashX = 1;
                
                const timeSinceSquash = Date.now() - this.lastSquash;
                
                if (distanceFromGround < 10 && this.vy > 0 && timeSinceSquash > 50) {
                    // Ground impact
                    const impact = Math.min(this.vy * 0.1, 0.3);
                    squashY = 1 - impact;
                    squashX = 1 + impact * 0.5;
                    this.lastSquash = Date.now();
                } else if (timeSinceSquash < 100) {
                    // Recovery from squash (ground or collision)
                    const recovery = timeSinceSquash / 100;
                    squashY = 0.8 + (0.2 * recovery);
                    squashX = 1.1 - (0.1 * recovery);
                }

                this.element.style.left = ballX + 'px';
                this.element.style.top = ballY + 'px';
                this.element.style.transform = `scaleY(${squashY}) scaleX(${squashX})`;

                // Update shadow
                const shadowX = this.x - 30;
                const shadowY = FLOOR_Y - 10;
                const shadowScale = Math.max(0.6, 1 - (FLOOR_Y - this.y) / 400);
                const shadowOpacity = Math.max(0.3, 0.5 - (FLOOR_Y - this.y) / 600);
                
                this.shadow.style.left = shadowX + 'px';
                this.shadow.style.top = shadowY + 'px';
                this.shadow.style.transform = `scale(${shadowScale})`;
                this.shadow.style.opacity = shadowOpacity;
            }

            checkCollision(otherBall) {
                if (this === otherBall || this.isDragging || otherBall.isDragging) {
                    return false;
                }

                const dx = otherBall.x - this.x;
                const dy = otherBall.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const minDistance = BALL_DIAMETER;

                if (distance < minDistance && distance > 0) {
                    // Collision detected - resolve overlap
                    const overlap = minDistance - distance;
                    const angle = Math.atan2(dy, dx);
                    
                    // Separate balls to prevent overlap
                    const separationX = Math.cos(angle) * overlap * 0.5;
                    const separationY = Math.sin(angle) * overlap * 0.5;
                    
                    this.x -= separationX;
                    this.y -= separationY;
                    otherBall.x += separationX;
                    otherBall.y += separationY;

                    // Calculate collision response (elastic collision)
                    const relativeVx = otherBall.vx - this.vx;
                    const relativeVy = otherBall.vy - this.vy;
                    const relativeSpeed = relativeVx * Math.cos(angle) + relativeVy * Math.sin(angle);

                    if (relativeSpeed > 0) {
                        // Balls are moving towards each other
                        const impulse = 2 * relativeSpeed * COLLISION_DAMPING;
                        
                        this.vx += impulse * Math.cos(angle);
                        this.vy += impulse * Math.sin(angle);
                        otherBall.vx -= impulse * Math.cos(angle);
                        otherBall.vy -= impulse * Math.sin(angle);

                        // Add squash effect on collision
                        const impact = Math.min(Math.abs(relativeSpeed) * 0.05, 0.2);
                        this.lastSquash = Date.now();
                        otherBall.lastSquash = Date.now();
                    }

                    return true;
                }

                return false;
            }

            updatePhysics() {
                if (!this.isDragging) {
                    // Apply gravity
                    this.vy += GRAVITY;

                    // Apply friction
                    this.vx *= FRICTION;

                    // Update position
                    this.x += this.vx;
                    this.y += this.vy;

                    // Bounce off floor
                    if (this.y >= FLOOR_Y) {
                        this.y = FLOOR_Y;
                        this.vy = -this.vy * BOUNCE_DAMPING;
                        this.vx *= FRICTION;
                        
                        if (Math.abs(this.vy) < 2) {
                            this.vy = 0;
                        }
                    }

                    // Bounce off walls
                    if (this.x <= BALL_RADIUS) {
                        this.x = BALL_RADIUS;
                        this.vx = -this.vx * BOUNCE_DAMPING;
                    } else if (this.x >= window.innerWidth - BALL_RADIUS) {
                        this.x = window.innerWidth - BALL_RADIUS;
                        this.vx = -this.vx * BOUNCE_DAMPING;
                    }

                    // Bounce off ceiling
                    if (this.y <= BALL_RADIUS) {
                        this.y = BALL_RADIUS;
                        this.vy = -this.vy * BOUNCE_DAMPING;
                    }
                }

                this.updatePosition();
            }

            checkAllCollisions() {
                // Check collisions with other balls (only check pairs once)
                const ballIndex = balls.indexOf(this);
                for (let i = ballIndex + 1; i < balls.length; i++) {
                    this.checkCollision(balls[i]);
                }
            }

            handleDrag(newX, newY) {
                const currentTime = Date.now();
                const deltaTime = Math.max(1, currentTime - this.lastDragTime);
                const deltaX = newX - this.lastDragX;
                const deltaY = newY - this.lastDragY;
                
                const newVx = (deltaX / deltaTime) * 16;
                const newVy = (deltaY / deltaTime) * 16;
                
                this.vx = this.vx * (1 - VELOCITY_SMOOTHING) + newVx * VELOCITY_SMOOTHING;
                this.vy = this.vy * (1 - VELOCITY_SMOOTHING) + newVy * VELOCITY_SMOOTHING;
                
                this.x = Math.max(BALL_RADIUS, Math.min(window.innerWidth - BALL_RADIUS, newX));
                this.y = Math.max(BALL_RADIUS, Math.min(FLOOR_Y, newY));
                
                this.lastDragX = this.x;
                this.lastDragY = this.y;
                this.lastDragTime = currentTime;
                
                this.updatePosition();
            }

            remove() {
                this.element.remove();
                this.shadow.remove();
            }
        }

        // Mouse and touch event handlers
        document.addEventListener('mousemove', (e) => {
            if (draggedBall && draggedBall.isDragging) {
                const newX = e.clientX - draggedBall.dragOffsetX;
                const newY = e.clientY - draggedBall.dragOffsetY;
                draggedBall.handleDrag(newX, newY);
            }
        });

        document.addEventListener('mouseup', () => {
            if (draggedBall) {
                draggedBall.isDragging = false;
                draggedBall = null;
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (draggedBall && draggedBall.isDragging) {
                const touch = e.touches[0];
                const newX = touch.clientX - draggedBall.dragOffsetX;
                const newY = touch.clientY - draggedBall.dragOffsetY;
                draggedBall.handleDrag(newX, newY);
                e.preventDefault();
            }
        });

        document.addEventListener('touchend', () => {
            if (draggedBall) {
                draggedBall.isDragging = false;
                draggedBall = null;
            }
        });

        // Spawn balls function
        function spawnBalls(count) {
            // Remove existing balls
            balls.forEach(ball => ball.remove());
            balls = [];
            draggedBall = null;

            // Spawn new balls
            for (let i = 0; i < count; i++) {
                const startX = (window.innerWidth / (count + 1)) * (i + 1);
                const startY = 100 + (i * 20); // Stagger vertically
                const ball = new Ball(i, startX, startY);
                balls.push(ball);
            }
        }

        // Spawn button handler
        spawnBtn.addEventListener('click', () => {
            const count = parseInt(ballCountInput.value) || 1;
            const clampedCount = Math.max(1, Math.min(50, count));
            ballCountInput.value = clampedCount;
            spawnBalls(clampedCount);
        });

        // Allow Enter key to spawn
        ballCountInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                spawnBtn.click();
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            FLOOR_Y = window.innerHeight - BALL_RADIUS;
            balls.forEach(ball => {
                ball.x = Math.max(BALL_RADIUS, Math.min(window.innerWidth - BALL_RADIUS, ball.x));
                ball.y = Math.min(ball.y, FLOOR_Y);
                ball.updatePosition();
            });
        });

        // Initialize with 1 ball
        spawnBalls(1);

        // Animation loop
        function animate() {
            // Update physics for all balls
            balls.forEach(ball => ball.updatePhysics());
            
            // Check collisions between all balls (after physics update)
            balls.forEach(ball => ball.checkAllCollisions());
            
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>